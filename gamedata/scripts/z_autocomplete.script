-- Autocomplete Tasks (23-03-17)
-- Autocomplete v3 (20-01-08)
-- For Anomaly 1.5 Update 4 Hotfix 8.1 (19-12-05)

valid_pda_devices = {
	["device_pda_1"] = true,
	["device_pda_2"] = true,
	["device_pda_3"] = true,
	["device_pda_milspec"] = true
}

local global_enable = nil
local pda_check = nil
local compensate_item_rewards = nil
local compensation_coefficient = nil

local assault_enable = nil
local bounty_enable = nil
local fate_enable = nil
local scripted_enable = nil
local fetch_enable = nil
local return_enable = nil
local measurements_enable = nil
local scanner_enable = nil

local snitch_enable = nil
local spring_clean_enable = nil
local defend_pump_station_enable = nil
local destroy_btrs_enable = nil
local research_hunt_enable = nil
local recover_tracker_enable = nil

local check_interval = nil
local finish_message_delay = nil
local reward_delay = nil
local whitelist = nil
local blacklist = nil
local _dbg = nil

local _task_cache = {}
local _finished_task_cache = {}


function dbg_printf(...)
	if _dbg then printf(...) end
end

function has_actor_pda()
	for k, v in pairs(valid_pda_devices) do
		if (db.actor:object(k) and true) and (v) then
			return true
		end
	end
	return false
end

function should_complete_by_task_functor(task_functor_name)
	-- Check assault task
	if task_functor_name == "assault_task_target_functor"
		-- or task_functor_name == "task_targets_lostzone_all" -- Assault Task with companions?
		then return assault_enable end

	-- Check bounty task
	if task_functor_name == "general_bounty_task"
		then return bounty_enable end

	-- Check fate task
	if task_functor_name == "general_fate"
		then return fate_enable end

	-- Check scripted task
	if task_functor_name == "recover_item_on_corpse_target_functor"
		then return scripted_enable end

	-- Check fetch task
	if task_functor_name == "general_fetch_task"
		or task_functor_name == "multifetch_target_functor"
		then return fetch_enable end

	-- Check return task
	if task_functor_name == "drx_sl_quest_item_task_target"
		then return return_enable end

	-- Check measurements task
	if task_functor_name == "general_measure"
		then return measurements_enable end

	-- Check scanner task
	if task_functor_name == "anomaly_scanner_task_target"
		then return scanner_enable end

	-- Check special tasks
	if task_functor_name == "top_10_task_target_functor" then return snitch_enable end
	if task_functor_name == "mutants_in_map_target" then return spring_clean_enable end
	if task_functor_name == "gd_task_target_functor" then return defend_pump_station_enable end
	if task_functor_name == "veh_destroy_tf" then return destroy_btrs_enable end
	if task_functor_name == "yan_ecolog_semenov_task_target_1" then return research_hunt_enable end
	if task_functor_name == "recover_mutant_data_target" then return recover_tracker_enable end

	return false
end


function do_autocompletion()
	-- Check if user enabled autocompletion
	if not global_enable then return end

	-- Check if user enabled the pda check and return if actor doesn't have a pda
	if pda_check and not has_actor_pda() then return end

	-- Interate tasks
	local tm = task_manager.get_task_manager()
	for tid, tsk in pairs(tm.task_info) do
		-- Proceed to check if task is not queued for completion yet
		if not _finished_task_cache[tid] then
			-- Complete task if the check returns true
			if should_autocomplete(tid, tsk.stage) then
				dbg_printf("[AT] Autocompleting task: %s", tid)
				_finished_task_cache[tid] = true
			
				CreateTimeEvent("autocomplete_tasks", "finish_message_delay", finish_message_delay, function()
					-- Send finish task dialog message from task giver
					send_confirmation_message(tid, tsk.task_giver_id)

					CreateTimeEvent("autocomplete_tasks", "reward_delay", reward_delay, function()
						-- Complete task
						tm:set_task_completed(tid)

						-- Remove task from queue
						_finished_task_cache[tid] = nil

						return true
					end)

					return true
				end)
			end
		end
	end
end

function send_confirmation_message(tid, sender_id)
	-- Check if task complete description exists
	local finish_message = _task_cache[tid].task_complete_descr
	if not finish_message then
		dbg_printf("[AT] Couldn't send confirmation message: finish message doesn't exist")
		return
	end

	-- Check if task giver is valid
	local sender_obj = alife_object(sender_id)
	if not sender_obj then
		dbg_printf("[AT] Couldn't send confirmation message: task giver is invalid")
		return
	end

	-- Check if task giver is a squad
	-- Note: the task giver id for the toolkit fetch tasks by technicians is the id of a squad for some reason
	if sender_obj:clsid() == clsid.online_offline_group_s then
		local commander_obj = alife_object(sender_obj:commander_id())
		if not commander_obj then
			dbg_printf("[AT] Couldn't send confirmation message: task giver is an invalid squad")
			return
		end

		sender_obj = commander_obj
	end

	xr_sound.set_sound_play(AC_ID, "pda_tips")
	local message_title = string.format("%s, %s", sender_obj:character_name(), game.translate_string(sender_obj:community()))
	db.actor:give_game_news(message_title, game.translate_string(finish_message), sender_obj:character_icon(), 0, 5000, 0)
end

function is_listed(list, tid)
	if list == "none" then return false end

	local tids = str_explode(list, ",")
	for i = 1, #tids do
		if tids[i] == tid then
			return true
		end
	end

	return false
end

function should_autocomplete(tid, stage)
	-- Check if task is already cached
	if not _task_cache[tid] then
		-- Check if task is defined in the task manager
		local parsed_data = utils_data.parse_ini_section_to_array(task_manager.task_ini, tid)
		if not parsed_data then
			dbg_printf("[AT] Unable to autocomplete task: %s", tid)
		end

		-- Add task to cache
		_task_cache[tid] = parsed_data or {}
	end

	local tsk = _task_cache[tid]

	-- Check if task reached last stage
	if not stage then return false end
	if not tsk.stage_complete then return false end
	if tonumber(tsk.stage_complete) ~= tonumber(stage) then return false end

	-- Check if task is whitelisted
	if is_listed(whitelist, tid) then return true end

	-- Check if task is blacklisted
	if is_listed(blacklist, tid) then return false end

	-- Check if task is not a storyline task
	if tsk.storyline and tsk.storyline == "true" then return false end

	-- Check if task has a whitelisted target functor
	if not tsk.target_functor then return false end
	if not should_complete_by_task_functor(tsk.target_functor) then return false end

	return true
end


function on_option_change()
	-- General options 
	global_enable = z_autocomplete_mcm.get_config("at_general", "enable")
	pda_check = z_autocomplete_mcm.get_config("at_general", "pda_check")
	compensate_item_rewards = z_autocomplete_mcm.get_config("at_general", "compensate_item_rewards")
	compensation_coefficient = z_autocomplete_mcm.get_config("at_general", "compensation_coefficient")

	-- General tasks options
	assault_enable = z_autocomplete_mcm.get_config("at_general_tasks", "assault")
	bounty_enable = z_autocomplete_mcm.get_config("at_general_tasks", "bounty")
	measurements_enable = z_autocomplete_mcm.get_config("at_general_tasks", "measurements")
	fate_enable = z_autocomplete_mcm.get_config("at_general_tasks", "fate")
	scripted_enable = z_autocomplete_mcm.get_config("at_general_tasks", "scripted")
	scanner_enable = z_autocomplete_mcm.get_config("at_general_tasks", "scanner")
	fetch_enable = z_autocomplete_mcm.get_config("at_general_tasks", "fetch")
	return_enable = z_autocomplete_mcm.get_config("at_general_tasks", "return")

	-- Special tasks options
	snitch_enable = z_autocomplete_mcm.get_config("at_special_tasks", "snitch")
	spring_clean_enable = z_autocomplete_mcm.get_config("at_special_tasks", "spring_clean")
	defend_pump_station_enable = z_autocomplete_mcm.get_config("at_special_tasks", "defend_pump_station")
	destroy_btrs_enable = z_autocomplete_mcm.get_config("at_special_tasks", "destroy_btrs")
	research_hunt_enable = z_autocomplete_mcm.get_config("at_special_tasks", "research_hunt")
	recover_tracker_enable = z_autocomplete_mcm.get_config("at_special_tasks", "recover_tracker")

	-- Other options
	check_interval = z_autocomplete_mcm.get_config("at_other", "check_interval")
	finish_message_delay = z_autocomplete_mcm.get_config("at_other", "finish_message_delay")
	reward_delay = z_autocomplete_mcm.get_config("at_other", "reward_delay")
	whitelist = z_autocomplete_mcm.get_config("at_other", "whitelist")
	blacklist = z_autocomplete_mcm.get_config("at_other", "blacklist")
	_dbg = z_autocomplete_mcm.get_config("at_other", "debug")
end

function actor_on_first_update()
	-- Run the check every 'check_interval' seconds
	CreateTimeEvent("autocomplete_tasks", "check_autocomplete_tasks", check_interval, function()
		do_autocompletion()
		ResetTimeEvent("autocomplete_tasks", "check_autocomplete_tasks", check_interval)
		return false
	end)
end

function on_game_start()
	on_option_change()
	RegisterScriptCallback("on_option_change", on_option_change)
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
end

local orig_task_callback = task_manager.task_callback
function task_manager.task_callback(tsk, state)
	-- Check if user wants to compensate items
	if (not global_enable) or (not compensate_item_rewards) then
		orig_task_callback(tsk, state)
		return
	end

	local tsk_id = tsk:get_id()

	-- Check if last stage
	if state ~= task.completed then
		dbg_printf("[AT] No compensation for task %s: not completed yet", tsk_id)
		orig_task_callback(tsk, state)
		return
	end

	-- Check if task id is cached
	if (not tsk_id) or (not _task_cache[tsk_id]) then
		dbg_printf("[AT] No compensation for task %s: task not cached", tsk_id)
		orig_task_callback(tsk, state)
		return
	end

	-- Check if task should get autocompleted
	if not should_autocomplete(tsk_id, _task_cache[tsk_id].stage_complete) then
		dbg_printf("[AT] No compensation for task %s: task category not enabled", tsk_id)
		orig_task_callback(tsk, state)
		return
	end

	-- Get task info about task
	local rtask = task_manager.get_task_manager().task_info[tsk_id]
	if (not rtask) or (not rtask.on_complete) or (not rtask.on_complete[1]) or (not rtask.on_complete[1][3]) then
		dbg_printf("[AT] No compensation for task %s: on_complete attribute is non-existent or invalid", tsk_id)
		orig_task_callback(tsk, state)
		return
	end

	local lowest_reward = 0
	local highest_reward = 0

	local temp_unknown_attr2 = nil
	local new_on_complete = {}
	for _, attrs in pairs(rtask.on_complete[1][3]) do
		-- attr[1] - attribute name (string)
		-- attr[2] - ? (number)
		-- attr[3] - attribute arguments (table)

		if (attrs) and (attrs[1]) and (attrs[2]) then
			-- Save the unknown variable just in case
			if not temp_unknown_attr2 then
				temp_unknown_attr2 = attrs[2]
			end

			local attr_name = attrs[1]
			local attr_args = attrs[3]

			if attr_name == "reward_money" then
				local money = tonumber(attr_args[1])
				lowest_reward = lowest_reward + money
				highest_reward = highest_reward + money
			elseif attr_name == "reward_random_money" then
				local money_min = tonumber(attr_args[1])
				local money_max = tonumber(attr_args[2])
				lowest_reward = lowest_reward + money_min
				highest_reward = highest_reward + money_max
			elseif attr_name == "reward_item" then
				local item_cost = get_base_cost(attr_args[1]) * get_item_cost_modifier()
				lowest_reward = lowest_reward + item_cost
				highest_reward = highest_reward + item_cost
			elseif attr_name == "reward_random_item" then
				local lowest_price = math.huge
				local highest_price = -math.huge

				for _, item in pairs(attr_args) do
					local item_cost = get_base_cost(item) * get_item_cost_modifier()

					-- Define lowest and highest bonus price
					if item_cost > highest_price then
						highest_price = item_cost
					end
					if item_cost < lowest_price then
						lowest_price = item_cost
					end
				end

				lowest_reward = lowest_reward + lowest_price
				highest_reward = highest_reward + highest_price
			else
				table.insert(new_on_complete, attrs)
			end
		end
	end

	-- Add total money reward to table copy if compensation exists
	if (lowest_reward > 0) and (highest_reward > 0) then
		local money_reward = {
			"reward_random_money",
			temp_unknown_attr2,
			{
				lowest_reward,
				highest_reward
			}

		}
		table.insert(new_on_complete, money_reward)
	end

	-- Assign table copy to 'on_complete' rewards table for task
	dbg_printf("[AT] Total reward after item compensation with min reward %s and max reward %s", lowest_reward, highest_reward)
	rtask.on_complete[1][3] = new_on_complete

	orig_task_callback(tsk, state)
end

function get_item_cost_modifier()
	return compensation_coefficient
end

function get_base_cost(item)
	local item_name, item_amount = string.match(item, "(.*)__([1-9])")

	-- Check if item is a multiuse item with a defined amount
	if item_name then
		local max_uses = ini_sys:r_float(item_name, "max_uses") or item_amount
		local item_cost = ini_sys:r_float(item_name, "cost") or 1000
		return item_cost * (item_amount / max_uses)
	else
		return ini_sys:r_float(item, "cost") or 500
	end
end
