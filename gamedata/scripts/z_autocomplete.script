-- Autocomplete Tasks (23-03-17)
-- Autocomplete v3 (20-01-08)
-- For Anomaly 1.5 Update 4 Hotfix 8.1 (19-12-05)

local get_mcm_config = z_autocomplete_mcm.get_config

local ini_trade = ini_file([[items\trade\trade_generic.ltx]])

valid_pda_devices = {
	["device_pda_1"] = true,
	["device_pda_2"] = true,
	["device_pda_3"] = true,
	["device_pda_milspec"] = true
}

local CHECK_INTERVAL = 2.0

local _task_cache = {}

function dbg_printf(...)
	if get_mcm_config("at_other", "debug") then printf(...) end
end

function has_actor_pda()
	for k, v in pairs(valid_pda_devices) do
		if (db.actor:object(k)) and (v) then
			return true
		end
	end
	return false
end

function should_complete_by_task_functor(task_functor_name)
	-- Check assault task
	if task_functor_name == "assault_task_target_functor"
		or task_functor_name == "task_targets_lostzone_all"
		then return get_mcm_config("at_general_tasks", "assault") end

	-- Check bounty task
	if task_functor_name == "general_bounty_task"
		then return get_mcm_config("at_general_tasks", "bounty") end

	-- Check hostage task
	if task_functor_name == "simulation_task_target"
		then return get_mcm_config("at_general_tasks", "hostage") end

	-- Check spy extraction task
	if task_functor_name == "spy_task_target_functor"
		then return get_mcm_config("at_general_tasks", "spy_extract") end

	-- Check fate task
	if task_functor_name == "general_fate"
		then return get_mcm_config("at_general_tasks", "fate") end

	-- Check scripted task
	if task_functor_name == "recover_item_on_corpse_target_functor"
		then return get_mcm_config("at_general_tasks", "scripted") end

	-- Check fetch task
	if task_functor_name == "general_fetch_task"
		or task_functor_name == "multifetch_target_functor"
		then return get_mcm_config("at_general_tasks", "fetch") end

	-- Check retrieve task
	if task_functor_name == "drx_sl_quest_item_task_target"
		then return get_mcm_config("at_general_tasks", "retrieve") end

	-- Check measurements task
	if task_functor_name == "general_measure"
		then return get_mcm_config("at_general_tasks", "measurements") end

	-- Check scanner task
	if task_functor_name == "anomaly_scanner_task_target"
		then return get_mcm_config("at_general_tasks", "scanner") end

	-- Check special tasks
	if task_functor_name == "top_10_task_target_functor" then return get_mcm_config("at_special_tasks", "snitch") end
	if task_functor_name == "mutants_in_map_target" then return get_mcm_config("at_special_tasks", "spring_clean") end
	if task_functor_name == "gd_task_target_functor" then return get_mcm_config("at_special_tasks", "defend_pump_station") end
	if task_functor_name == "veh_destroy_tf" then return get_mcm_config("at_special_tasks", "destroy_btrs") end
	if task_functor_name == "yan_ecolog_semenov_task_target_1" then return get_mcm_config("at_special_tasks", "research_hunt") end
	if task_functor_name == "recover_mutant_data_target" then return get_mcm_config("at_special_tasks", "recover_tracker") end

	return false
end


function do_autocompletion()
	-- Check if user enabled autocompletion
	if not get_mcm_config("at_general", "enable") then return end

	-- Check if user enabled the pda check and return if actor doesn't have a pda
	if get_mcm_config("at_general", "pda_check") and not has_actor_pda() then return end

	-- Interate tasks
	local tm = task_manager.get_task_manager()
	for tid, tsk in pairs(tm.task_info) do
		-- Complete task if the check returns true
		if not should_autocomplete(tid, tsk.stage) then
			goto continue
		end

		dbg_printf("[AT] Autocompleting task: %s", tid)
		send_confirmation_message(tid, tsk.task_giver_id)
		tm:set_task_completed(tid)

		:: continue ::
	end
end

function send_confirmation_message(tid, sender_id)
	-- Check if task complete description exists
	local finish_message = _task_cache[tid].task_complete_descr
	if not finish_message then
		dbg_printf("[AT] Couldn't send confirmation message: finish message doesn't exist")
		return
	end

	-- Check if task giver is valid
	local sender_obj = alife_object(sender_id)
	if not sender_obj then
		dbg_printf("[AT] Couldn't send confirmation message: task giver is nil")
		return
	end

	-- Check if task giver is a squad
	-- Note: the task giver id for the toolkit fetch tasks by technicians is the id of a squad for some reason
	if sender_obj:clsid() == clsid.online_offline_group_s then
		local commander_obj = alife_object(sender_obj:commander_id())
		if not commander_obj then
			dbg_printf("[AT] Couldn't send confirmation message: task giver is an invalid squad")
			return
		end

		sender_obj = commander_obj
	end

	-- Still check if valid
	if (not sender_obj.character_name) or (not sender_obj.community) or (not sender_obj.character_icon) then
		dbg_printf("[AT] Couldn't send confirmation message: task giver is invalid with clsid %s", sender_obj.clsid and sender_obj:clsid())
		return
	end

	xr_sound.set_sound_play(AC_ID, "pda_tips")
	local message_title = string.format("%s, %s", sender_obj:character_name(), game.translate_string(sender_obj:community()))
	db.actor:give_game_news(message_title, game.translate_string(finish_message), sender_obj:character_icon(), 0, 5000, 0)
end

function is_listed(list, tid)
	if list == "none" then return false end

	local tids = str_explode(list, ",")
	for i = 1, #tids do
		if tids[i] == tid then
			return true
		end
	end

	return false
end

function should_autocomplete(tid, stage)
	-- Check if task is already cached
	if not _task_cache[tid] then
		-- Check if task is defined in the task manager
		local parsed_data = utils_data.parse_ini_section_to_array(task_manager.task_ini, tid)
		if not parsed_data then
			dbg_printf("[AT] Unable to autocomplete task: %s", tid)
		end

		-- Add task to cache
		_task_cache[tid] = parsed_data or {}
	end

	local tsk = _task_cache[tid]

	-- Check if task reached last stage
	if not stage then return false end
	if not tsk.stage_complete then return false end
	if tonumber(tsk.stage_complete) ~= tonumber(stage) then return false end

	-- Check if task is whitelisted
	if is_listed(get_mcm_config("at_other", "whitelist"), tid) then return true end

	-- Check if task is blacklisted
	if is_listed(get_mcm_config("at_other", "blacklist"), tid) then return false end

	-- Check if task is not a storyline task
	if (tsk.storyline) and (tsk.storyline == "true") then return false end

	-- Check if task has a whitelisted target functor
	if not tsk.target_functor then return false end
	if not should_complete_by_task_functor(tsk.target_functor) then return false end

	return true
end

function actor_on_first_update()
	-- Run the check every 'CHECK_INTERVAL' seconds
	CreateTimeEvent("autocomplete_tasks", "check_autocomplete_tasks", CHECK_INTERVAL, function()
		do_autocompletion()
		ResetTimeEvent("autocomplete_tasks", "check_autocomplete_tasks", CHECK_INTERVAL)
		return false
	end)
end

function on_game_start()
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
end

local orig_task_callback = task_manager.task_callback
function task_manager.task_callback(tsk, state)
	-- Check if user wants to compensate items
	if (not get_mcm_config("at_general", "enable")) or (not get_mcm_config("at_general", "compensate_item_rewards")) then
		orig_task_callback(tsk, state)
		return
	end

	local tsk_id = tsk:get_id()

	-- Check if last stage
	if state ~= task.completed then
		dbg_printf("[AT] No compensation for task %s: not completed yet", tsk_id)
		orig_task_callback(tsk, state)
		return
	end

	-- Check if task id is cached
	if (not tsk_id) or (not _task_cache[tsk_id]) then
		dbg_printf("[AT] No compensation for task %s: task not cached", tsk_id)
		orig_task_callback(tsk, state)
		return
	end

	-- Check if task should get autocompleted
	if not should_autocomplete(tsk_id, _task_cache[tsk_id].stage_complete) then
		dbg_printf("[AT] No compensation for task %s: task category not enabled", tsk_id)
		orig_task_callback(tsk, state)
		return
	end

	-- Get task info about task
	local rtask = task_manager.get_task_manager().task_info[tsk_id]
	if (not rtask) or (not rtask.on_complete) or (not rtask.on_complete[1]) or (not rtask.on_complete[1][3]) then
		dbg_printf("[AT] No compensation for task %s: on_complete attribute is non-existent or invalid", tsk_id)
		orig_task_callback(tsk, state)
		return
	end

	local lowest_reward = 0
	local highest_reward = 0

	local temp_unknown_attr2 = nil
	local new_on_complete = {}
	for _, attrs in pairs(rtask.on_complete[1][3]) do
		-- attr[1] - attribute name (string)
		-- attr[2] - ? (number)
		-- attr[3] - attribute arguments (table)

		if not ((attrs) and (attrs[1]) and (attrs[2])) then
			goto continue
		end

		-- Save the unknown variable just in case
		if not temp_unknown_attr2 then
			temp_unknown_attr2 = attrs[2]
		end

		local attr_name = attrs[1]
		local attr_args = attrs[3]

		if attr_name == "reward_money" then
			local money = tonumber(attr_args[1])
			lowest_reward = lowest_reward + money
			highest_reward = highest_reward + money
		elseif attr_name == "reward_random_money" then
			local money_min = tonumber(attr_args[1])
			local money_max = tonumber(attr_args[2])
			lowest_reward = lowest_reward + money_min
			highest_reward = highest_reward + money_max
		elseif attr_name == "reward_item" then
			local item_cost = get_base_cost(attr_args[1]) * get_sell_discount() * get_mcm_config("at_general", "compensation_coefficient")
			lowest_reward = lowest_reward + item_cost
			highest_reward = highest_reward + item_cost
		elseif attr_name == "reward_random_item" then
			local lowest_price = math.huge
			local highest_price = -math.huge

			for _, item in pairs(attr_args) do
				local item_cost = get_base_cost(item) * get_sell_discount() * get_mcm_config("at_general", "compensation_coefficient")

				-- Define lowest and highest bonus price
				if item_cost > highest_price then
					highest_price = item_cost
				end
				if item_cost < lowest_price then
					lowest_price = item_cost
				end
			end

			lowest_reward = lowest_reward + lowest_price
			highest_reward = highest_reward + highest_price
		else
			table.insert(new_on_complete, attrs)
		end

		:: continue ::
	end

	-- Add total money reward to table copy if compensation exists
	if (lowest_reward > 0) and (highest_reward > 0) then
		local money_reward = {
			"reward_random_money",
			temp_unknown_attr2,
			{
				lowest_reward,
				highest_reward
			}

		}
		table.insert(new_on_complete, money_reward)
	end

	-- Assign table copy to 'on_complete' rewards table for task
	dbg_printf("[AT] Total reward after item compensation with min reward %s and max reward %s", lowest_reward, highest_reward)
	rtask.on_complete[1][3] = new_on_complete

	orig_task_callback(tsk, state)
end

function get_sell_discount()
	local condlist = ini_trade and ini_trade:r_string_to_condlist("trader", "discounts")
	local sect = condlist and xr_logic.pick_section_from_condlist(db.actor, nil, condlist)
	if (not sect) or (sect == "") then
		return 1 
	end

	local factor = ini_trade:r_float_ex(sect, "sell") or 1
	local eco_factor = game_difficulties.get_eco_factor("sell") or 1
	
	dbg_printf("[AT] Using sell discount %s for compensation", factor * eco_factor)
	return factor * eco_factor
end

function get_base_cost(item)
	local item_name, item_amount = string.match(item, "(.*)__([1-9])")

	-- Check if item is a multiuse item with a defined amount
	if item_name then
		local max_uses = ini_sys:r_float(item_name, "max_uses") or item_amount
		local item_cost = ini_sys:r_float(item_name, "cost") or 1000
		return item_cost * (item_amount / max_uses)
	else
		return ini_sys:r_float(item, "cost") or 500
	end
end
